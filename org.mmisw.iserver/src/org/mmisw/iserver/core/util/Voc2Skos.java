package org.mmisw.iserver.core.util;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.io.IOUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.mmisw.iserver.core.util.csv.BaseParser;
import org.mmisw.ont.JenaUtil2;

import com.hp.hpl.jena.ontology.OntModel;
import com.hp.hpl.jena.rdf.model.Model;
import com.hp.hpl.jena.rdf.model.ModelFactory;
import com.hp.hpl.jena.rdf.model.Property;
import com.hp.hpl.jena.rdf.model.RDFWriter;
import com.hp.hpl.jena.rdf.model.Resource;
import com.hp.hpl.jena.vocabulary.RDFS;

/**
 * Voc2Skos conversion utility.
 * 
 * @author Carlos Rueda
 */
public class Voc2Skos {

	/**
	 * Reads an ontology from a text file in the format
	 * specified in issue #133.
	 * 
	 * @param file
	 * @return
	 * @throws IOException
	 */
	public static OntModel loadModel(File file) throws IOException {
		Voc2Skos v2s = new Voc2Skos(file);
		v2s.convert();
		// wrap it in an OntModel and return it:
		OntModel ontModel = ModelFactory.createOntologyModel();
		ontModel.add(v2s.model);
		ontModel.setNsPrefixes(v2s.model);
		return ontModel;
	}
	
	/**
	 * Just a quick way to write the base model, which was the actual model
	 * generated. We had to wrap it in an OntModel to comply with the outside
	 * code that mainly handles OntModel's.
	 * 
	 * <p>
	 * NOTE: This method should be called with a model generated by {@link #loadModel(File)}.
	 * 
	 * @param ontModel  model generated by {@link #loadModel(File)}.
	 * @param file
	 * @param base
	 * @throws IOException
	 */
	public static void saveOntModelXML(OntModel ontModel, File file,
			String base) throws IOException {

		// extract the actual model generated.
		Model model = ontModel.getBaseModel();
		
		String xmlbase = null;
		String namespace = null;
		
		if ( base != null ) {
			xmlbase = JenaUtil2.removeTrailingFragment(base);
			namespace = JenaUtil2.appendFragment(base);
		}
		
		FileOutputStream out = new FileOutputStream(file);
		
		try {
			// NOTE When model is OntModel, the following generates a bunch of stuff
			RDFWriter writer = model.getWriter("RDF/XML-ABBREV");
			writer.setProperty("showXmlDeclaration", "true");
			writer.setProperty("relativeURIs", "same-document,relative");
			writer.setProperty("tab", "4");
			if ( xmlbase != null ) {
				writer.setProperty("xmlbase", xmlbase);
			}

			writer.write(model, out, namespace);
		}
		finally {
			IOUtils.closeQuietly(out);
		}
	}

	
	/** standard properties that are recognized by its typical prefix in the preamble and 
	 * in the header columns.
	 * NOTE: Not exhaustive; I'm choosing the most obvious ones, taking into account that
	 * they can have string as the range.
	 */
	private static final Map<String,Property> STD_PROPS = new HashMap<String,Property>();
	static {
		Property[] skosProps = {
			Skos.prefLabel, Skos.altLabel, Skos.hiddenLabel, 
			
			Skos.definition, Skos.changeNote, Skos.editorialNote, Skos.example, 
			Skos.historyNote, Skos.note, Skos.scopeNote
		};
		for ( Property prop : skosProps ) {
			STD_PROPS.put("skos:" +prop.getLocalName(), prop);
		}
		
		Property[] rdfsProps = {
				RDFS.label, RDFS.comment, RDFS.isDefinedBy, RDFS.seeAlso,	
		};
		for ( Property prop : rdfsProps ) {
			STD_PROPS.put("rdfs:" +prop.getLocalName(), prop);
		}
	}

	/** the params that are recognized in the preamble: 
	 * a few key properties and all the standard properties above 
	 */
	private static final List<String> RECOGNIZED_PARAMS_IN_PREAMBLE = 
		new ArrayList<String>(Arrays.asList(
			"ontologyURI",
			"class",
			"indent.string",
			"indent.property",
			"separator"
	));
	static {
		RECOGNIZED_PARAMS_IN_PREAMBLE.addAll(STD_PROPS.keySet());
	}

	/** pattern for defs in the preamble section:  something = something */
	private static final Pattern PARAM_PATTERN = Pattern.compile("\\s*([^\\s=]+)\\s*=\\s*(.*)$");
	
	
	////////////////////////////////////////////////////////////////////////////
	// instance.
	////////////////////////////////////////////////////////////////////////////
	
	
	private final Log log = LogFactory.getLog(Voc2Skos.class);
	
	
	private BaseParser parser;
	private String[] record;

	private Map<String,String> givenParams;
	
	private String[] header;

	private Map<String,String> workParams;
	
	private Property[] props;
	
	private Model model;
	private Resource conceptSubClass;
	private int numConcepts = 0;
	
	
	
	private Voc2Skos(File file) throws IOException{
		parser = BaseParser.createParser(file);
		givenParams = new LinkedHashMap<String,String>();
		workParams = new LinkedHashMap<String,String>();
	}
	
	private void convert() throws IOException {
		_debug("convert: start");
		try {
			doConvert();
		}
		finally {
			parser.close();
		}
	}
	
	private void doConvert() throws IOException {
		_setDefaultWorkParams();
		
		_parsePreamble();
		_prepareModel();
		_parseHeader();
		_prepareProperties();
		_parseTerms();
	}
	
	private void _setDefaultWorkParams() {
		workParams.put("ontologyUri", "http://example.org");
		workParams.put("class", "UnnamedConcept");
		workParams.put("skos:prefLabel", "Unnamed Concept");
	}

	/**
	 * scans preamble section; return line where terms section begins, or null.
	 * @throws IOException 
	 */
	private void _parsePreamble() throws IOException {
		while ( parser.hasNext() ) {
			record = parser.getNext();
			
			if ( record.length == 1 ) {
				Matcher matcher = PARAM_PATTERN.matcher(record[0]);
				if ( matcher.matches() ) {
					String paramName = matcher.group(1);
					String paramValue = matcher.group(2);
					_putGivenParam(paramName, paramValue);
				}
			}
			else {
				break;
			}
		}
		_debugParams("Given params: ", givenParams);
		
		workParams.putAll(givenParams);
		
		workParams.put("namespace", JenaUtil2.appendFragment(workParams.get("ontologyURI")));
		
		_debugParams("Work params: ", workParams);
		
		if ( record == null ) {
			throw parser.error("Expecting terms section");
		}
	}

	private void _prepareModel() {
		final String classId = workParams.get("class");
		final String namespace = workParams.get("namespace");
		final String conceptUri = namespace + classId;
		
		model = Skos.createModel();
		model.setNsPrefix("", namespace);
		conceptSubClass = Skos.addConceptSubClass(model, conceptUri);
		
		// associate indicated standard properties:
		for ( String paramName : workParams.keySet() ) {
			Property stdProp = STD_PROPS.get(paramName);
			if ( stdProp != null ) {
				conceptSubClass.addProperty(stdProp, workParams.get(paramName));
			}
		}
		
		_debug("namespace:   " +namespace);
		_debug("conceptUri:  " +conceptUri);
		
	}
	
	private void _parseHeader() throws IOException {
		header = record;
		if ( header.length == 0 ) {
			throw parser.error("No header columns");
		}
	}

	private void _prepareProperties() {

		// header[0] may be "uri" (ignoring case) or any other string.
		// If "uri", the values in first column will determine the complete URI of the term.
		// See below.
		//
		
		// Note, props[0] not used--we want to keep symmetry in the subindexing
		props = new Property[header.length];
		
		// create datatype properties -- note that we start with 2nd column
		for ( int jj = 1; jj < header.length; jj++ ) {
			String colName = header[jj].trim();
			
			if ( STD_PROPS.get(colName) != null ) {
				props[jj] = STD_PROPS.get(colName);
			}
			else {
				// user-given property.
				
				String propName = colName.replaceAll("\\s", "_"); // TODO complement correct propName
				String propUri = workParams.get("namespace") + propName;
				props[jj] = Skos.addDatatypeProperty(model, conceptSubClass, propUri , colName);
				
				_debug("propUri:  " +propUri);
			}
		}
	}
	
	private void _parseTerms() throws IOException {
		// Now, create the concepts.
		while ( parser.hasNext() ) {
			String[] row = parser.getNext();
			
			String ID = row[0].trim();
			
			if ( row.length == 0 ) {
				// should not happen.
				continue;
			}
			
			Resource concept;
			String conceptURI;
			if ( "uri".equalsIgnoreCase(header[0].trim()) ) {
				// conceptURI fully given by ID
				conceptURI = ID;
			}
			else {
				// conceptURI given by namespace and ID
				conceptURI = workParams.get("namespace") + ID;
			}
			concept = _createConcept(conceptURI);
			_debug("conceptURI:  " +conceptURI);
			
			final int count = Math.min(row.length, header.length);
			
			for ( int jj = 1; jj < count; jj++ ) {
				Property prop = props[jj];
				String colValue = row[jj].trim();
				
				concept.addProperty(prop, colValue);
			}
		}
		
		_debug("convert: ontology created: " +numConcepts+ " concepts.");
	}

	private void _putGivenParam(String paramName, String paramValue) throws IOException {
		paramName = _unquote(paramName);
		
		if ( ! RECOGNIZED_PARAMS_IN_PREAMBLE.contains(paramName) ) {
			parser.error("Unrecognized parameter in preamble: " +paramName+ 
					"\nValid parameters in preamble are: " +RECOGNIZED_PARAMS_IN_PREAMBLE);
		}
		paramValue = _unquote(paramValue);
		
		if ( "separator".equals(paramValue) ) {
			if ( paramValue.length() != 1 ) {
				throw parser.error("separator string must be a single character");
			}
			parser.setSeparator(paramValue.charAt(0));
		}

		givenParams.put(paramName, paramValue);
	}

	private String _unquote(String str) {
		str = str.trim();
		while ( str.length() > 1 && str.charAt(0) == '"' && str.charAt(str.length() - 1) == '"' ) {
			str = str.substring(1, str.length() - 1);
		}
		return str;
	}
	
	private void _debugParams(String label, Map<String,String> params) {
		_debug(label);
		for ( Entry<String, String> entry : params.entrySet() ) {
			_debug("\t" +entry.getKey()+ " = [" +entry.getValue()+ "]");
		}
	}

	private void _debug(String msg) {
		if ( log.isDebugEnabled() ) {
			log.debug(msg);
		}
		System.out.println("!!!! " +msg);
	}

	private Resource _createConcept(String uri) {
		Resource concept = model.createResource(uri, conceptSubClass);
		numConcepts++;
		return concept;
	}

	
	public static void main(String[] args) throws IOException {
		File file = new File("resource/voc2skos-example.csv");
		OntModel model = loadModel(file);
		File fileOut = new File("resource/voc2skos-example.rdf");
		String base = model.getNsPrefixURI("");
		Voc2Skos.saveOntModelXML(model, fileOut, base);
	}
}
