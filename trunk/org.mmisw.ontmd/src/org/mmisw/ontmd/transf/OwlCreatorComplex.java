package org.mmisw.ontmd.transf;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.TimeZone;

import org.apache.log4j.Logger;
import org.mmi.util.ResourceLoader;

import com.hp.hpl.jena.ontology.DatatypeProperty;
import com.hp.hpl.jena.ontology.Individual;
import com.hp.hpl.jena.ontology.ObjectProperty;
import com.hp.hpl.jena.ontology.OntClass;
import com.hp.hpl.jena.ontology.OntModel;
import com.hp.hpl.jena.ontology.Ontology;
import com.hp.hpl.jena.rdf.model.Resource;
import com.hp.hpl.jena.vocabulary.DC;
import com.hp.hpl.jena.vocabulary.RDFS;
import com.infomata.data.CSVFormat;
import com.infomata.data.DataFile;
import com.infomata.data.DataRow;
import com.infomata.data.TabFormat;

import edu.drexel.util.rdf.JenaUtil;
import edu.drexel.util.rdf.OwlModel;

//import org.eclipse.core.runtime.IProgressMonitor;
interface IProgressMonitor {
	
}



/**
 * (Copied/Adapted from org.mmi.ont.voc2owl.trans
 * for "easy" adjustments -- Carlos Rueda)
 * <p><p><p>
 * 
 * Creates an ontology from an ASCII file CSV or TAB separated value. First
 * header is the label of the terms First column will be converted to the ID
 * 
 * @author bermudez
 */
public class OwlCreatorComplex {

	public static String ONE_CLASS_ALL_INSTANCES = "ONE_CLASS_ALL_INSTANCES";

	public static String CLASS_HIERARCHY = "CLASS_HIERARCHY";

	private String convertionType = CLASS_HIERARCHY;

	private OntModel newOntModel;

	private OntClass classForTerms;

	private StringBuffer buf;

	private long begin;

	private Resource[] res;

	private ObjectProperty[] propetiesForHierarchiesUp_Down;

	private ObjectProperty[] propetiesForHierarchiesDown_Up;

	int idAutogenerated = 0;

	private final Transformation trans;

//	private IProgressMonitor monitor;

	private StringManipulationInterface stringManipulation;

	private static Logger logger = Logger.getLogger(OwlCreatorComplex.class);

	public OwlCreatorComplex(Transformation transformation) {

		this.trans = transformation;
		begin = System.currentTimeMillis();
		buf = new StringBuffer(1000);
		stringManipulation = new StringManipulationUtil();

	}

	public OwlCreatorComplex(Transformation trans, IProgressMonitor monitor) {
		this(trans);
//		this.monitor = monitor;
	}

	private void appendAction(String action) {
//		if (monitor != null) {
//			monitor.subTask(action);
//		}
		logger.info(action);

	}

	public void convertAndSave() throws Exception {
		try {
			convert();
			saveNewOntology();

		} catch (Exception e) {
			throw e;
		}

	}

	public void convertAndSave(String fileOut) throws Exception {
		trans.setFileOut(fileOut);
		convertAndSave();

	}

	private void createNewOntology() {
		try {
			newOntModel = new OwlModel(JenaUtil.createDefaultOntModel());
			String ns_ = JenaUtil.getURIForNS(trans.getNS());
			String base_ = JenaUtil.getURIForBase(trans.getNS());
			newOntModel.setNsPrefix("", ns_);
			Ontology ont = newOntModel.createOntology(base_);
			logger.info("New ontology created with namespace " + ns_ + " base "
					+ base_);

			if (trans.getTitle() != null) {
				ont.addProperty(DC.title, trans.getTitle());
			}
			if (trans.getSource() != null) {
				ont.addProperty(DC.source, trans.getSource());
			}
			if (trans.getSubject() != null) {
				ont.addProperty(DC.subject, trans.getSubject());
			}
			if (trans.getCreator() != null) {

				ont.addProperty(DC.creator, trans.getCreator());
			}
			if (trans.getDescription() != null) {
				String urlMoreinformation = trans.getURLMoreInformation() == null ? ""
						: "\n More information: "
								+ trans.getURLMoreInformation();

				ont.addProperty(DC.description, trans.getDescription()
						+ urlMoreinformation);
			}
			if (trans.getContributor() != null) {

				ont.addProperty(DC.contributor, trans.getContributor());
			}
			Date date = new Date(System.currentTimeMillis());
			SimpleDateFormat sdf = new SimpleDateFormat(
					"yyyy-MM-dd'T'HH:mm:ssZ");
			sdf.setTimeZone(TimeZone.getTimeZone("GMT"));
			String formatted = sdf.format(date);
			ont.addProperty(DC.date, formatted);
			removeNotNecessaryNS();

		} catch (Exception e) {
			logger
					.error("Error creating ontology metadata. Not all metadata was created.");
		}
	}

	/**
	 * 
	 */
	public void outputLog(String logFile) {
		try {
			File f = new File(logFile);
			FileWriter fw = new FileWriter(f);
			fw.write(buf.toString());
			fw.close();
		} catch (IOException e) {
			e.printStackTrace();
		}

	}

	private void removeNotNecessaryNS() {
		newOntModel.removeNsPrefix("rss");
		newOntModel.removeNsPrefix("jms");
		newOntModel.removeNsPrefix("vcard");
		newOntModel.removeNsPrefix("daml");

	}

	private void saveNewOntology() throws IOException {
//		if (monitor != null) {
//			monitor.subTask("Saving ontology");
//		}

		String fileOut = trans.getFileOut();

		if (!fileOut.contains(File.separator)) {
			String fileIn = ResourceLoader.getPath(trans.getFileIn());
			String path = fileIn.substring(0, fileIn
					.lastIndexOf(File.separator));
			fileOut = path + File.separator + fileOut;
		}

		JenaUtil.saveModelXML(newOntModel, fileOut);
		appendAction("Time in sec of the conversion: "
				+ (System.currentTimeMillis() - begin) / 1000);
		appendAction("New Ontology saved in: " + fileOut);
		appendAction("Size of the new Ontology: " + newOntModel.size());
		File file = new File(trans.getFileOut());
		Date date = new Date(file.lastModified());
		java.text.SimpleDateFormat df = new SimpleDateFormat(
				"yyyy-MM-dd'T'H:mm:ss");

		appendAction("Time stamp of the file " + df.format(date));
	}

	private boolean shouldBeConverted(int column) {
		if (trans.getConvertToClass() != null) {
			int[] classColumns = trans.getConvertToClass();

			for (int i = 0; i < classColumns.length; i++) {
				if (classColumns[i] == column) {
					return true;

				}
			}
		}
		return false;

	}

	private String getGoodName(DataRow row, int id) {
		return trans.getNS() + cleanStringforID(row.getString(id).trim());
	}

	private String getGoodNameFirstUpperCase(DataRow row, int id) {

		return trans.getNS()
				+ setFirstUpperCase(cleanStringforID(row.getString(id).trim()));
	}

	private boolean isGood(DataRow row, int id) {
		return row.getString(id).trim().length() > 0;

	}

	private Individual createIndividual(DataRow row, int id, OntClass cs) {

		if (isGood(row, id)) {
			String resourceString = getGoodName(row, id);
			Individual ind = newOntModel.createIndividual(resourceString, cs);
			ind.addProperty(RDFS.label, row.getString(id).trim());
			appendAction("ind created " + ind);
			return ind;
		}
		return null;
	}

	private Individual getIndividual(DataRow row, int id) {
		if (isGood(row, id)) {
			String resourceString = getGoodName(row, id);

			return newOntModel.getIndividual(resourceString);
		} else {
			return null;
		}

	}

	private Individual createAutoGeneratedIdIndividual(DataRow row, int id,
			OntClass cs) {

		Individual ind = newOntModel.createIndividual("individual"
				+ idAutogenerated++, cs);
		DatatypeProperty dp = newOntModel.createDatatypeProperty(trans.getNS()
				+ "originalLabel");
		ind.addProperty(dp, row.getString(id).trim());
		return ind;

	}

	private String setFirstUpperCase(String s) {
		// return s;
		return s.substring(0, 1).toUpperCase() + s.substring(1);
	}

	private OntClass createClassNameGiven() {
		String resourceString = trans.getNS()
				+ setFirstUpperCase(cleanStringforID(trans
						.getNameForPrimaryClass()));

		appendAction("class created " + resourceString);
		OntClass cls = newOntModel.createClass(resourceString);
		cls.addProperty(RDFS.label, trans.getNameForPrimaryClass());
		return cls;

	}

	private OntClass createClass(DataRow row, int id) {
		String resourceString = getGoodNameFirstUpperCase(row, id);

		
		OntClass cls = newOntModel.getOntClass(resourceString);
		if (cls == null) {
			 cls = newOntModel.createClass(resourceString);
			 appendAction("class created " + resourceString);
		}
		return cls;
	}

	private DatatypeProperty createDatatypeProperty(DataRow row, int id) {
		String resourceString = getGoodName(row, id).toLowerCase();
		appendAction("datatype Property created " + resourceString);
		DatatypeProperty p = newOntModel.createDatatypeProperty(resourceString);
		p.addProperty(RDFS.label, row.getString(id).trim());
		p.addDomain(classForTerms);
		return p;
	}

	private ObjectProperty getPropertyForARangeClass(OntClass cs) {
		String nameOfProperty = "has" + cs.getLocalName();
		ObjectProperty op = newOntModel.createObjectProperty(cs.getNameSpace()
				+ nameOfProperty);
		op.setDomain(classForTerms);
		op.setRange(cs);

		return op;

	}

	private ObjectProperty getPropertyForARangeClassWhenTreatedAsHiera(
			OntClass domain, OntClass range) {

		String domainLocal = domain.getLocalName();
		String rangeLocal = range.getLocalName();
		String ns = trans.getNS();
		String propertyName = "is" + domainLocal + "Of" + rangeLocal;

		ObjectProperty op = newOntModel.createObjectProperty(ns + propertyName);
		if (!op.hasDomain(domain)) {
			op.setDomain(domain);
		}

		if (!op.hasRange(range)) {
			op.setRange(range);
		}
		return op;

	}

	private void createPropertiesAndClasses(DataRow row) {
		int size = row.size();
		res = new Resource[size];

		if (trans.isTreatAsHierarchy()) {
			propetiesForHierarchiesUp_Down = new ObjectProperty[size - 1];
			propetiesForHierarchiesDown_Up = new ObjectProperty[size - 1];
			for (int i = 0; i < size; i++) {
				res[i] = createClass(row, i);

			}

			for (int i = 0; i < res.length - 1; i++) {
				OntClass cls1 = (OntClass) res[i];
				OntClass cls2 = (OntClass) res[i + 1];

				ObjectProperty pud = getPropertyForARangeClassWhenTreatedAsHiera(
						cls1, cls2);
				propetiesForHierarchiesUp_Down[i] = pud;
				ObjectProperty pdu = getPropertyForARangeClassWhenTreatedAsHiera(
						cls2, cls1);
				propetiesForHierarchiesDown_Up[i] = pdu;
				pud.setInverseOf(pdu);

			}

		} else {
			// object properties is set up later, when creating individuals

			int id = trans.getColumnForPrimaryClass();
			// create primary class
			if (trans.getNameForPrimaryClass() != null) {
				classForTerms = createClassNameGiven();
				System.out.println("class for terms created " + classForTerms);

			} else {
				classForTerms = createClass(row, id);
				System.out.println("class for terms created " + classForTerms);
			}

			for (int i = 0; i < size; i++) {

				// first row should not be converted to a class
				if (i != id && shouldBeConverted(i)) {
					appendAction("converting column header " + i + " to class");
					res[i] = createClass(row, i);
				} else {
					appendAction("converting column header " + i
							+ " to a datatype property");
					res[i] = createDatatypeProperty(row, i);
				}
			}
		}

	}

	private DataFile createDataFile() throws Exception {
		DataFile read = null;

		if (trans.getFormat() == Transformation.CSV) {
			read = DataFile.createReader("8859_1");
			read.setDataFormat(new CSVFormat());

		} else if (trans.getFormat() == Transformation.TAB) {
			read = DataFile.createReader("8859_2");
			read.setDataFormat(new TabFormat());

		} else {
			throw new Exception(
					"The given format in the property file is unkown. "
							+ "Only '" + "tab' and 'csv"
							+ " values are supported. ");
		}

		return read;
	}

	public void convert() throws Exception {
		logger.info("Transforming: " + trans.getFileIn());
		//		
		FileReader fr = null;
		try {
			fr = new FileReader(trans.getFileIn());
		} catch (FileNotFoundException e) {
			try {
				fr = new FileReader(ResourceLoader.getPath(trans.getFileIn()));
			} catch (FileNotFoundException e1) {
				logger.error("File: " + trans.getFileIn() + " was not found");
				// e1.printStackTrace();
				
				// do not continue:
				throw new Exception("File: " + trans.getFileIn() + " was not found");
			}
		}

		BufferedReader in = new BufferedReader(fr);
		int nl = 0;
		while (in.readLine() != null) {
			nl++;
		}
		in.close();
//		int total = (int) (nl * 1.3);
//		if (monitor != null) {
//			monitor.beginTask("Transforming " + trans.getFileIn() + " to OWL",
//					total);
//		}
		createNewOntology();

		// set conversion type
		convertionType = trans.getConvertionType();

		if (convertionType.equalsIgnoreCase(ONE_CLASS_ALL_INSTANCES)) {
			createOntologIndividuals();
		} else if (convertionType.equalsIgnoreCase(CLASS_HIERARCHY)) {
			createOntologyClassHierarchy();
		}

	}

	private void createOntologIndividuals() throws Exception {

		DataFile read = createDataFile();

		try {
			try {
				read.open(new File(trans.getFileIn()));
			} catch (IOException e) {
				try {
					read.open(new File(ResourceLoader
							.getPath(trans.getFileIn())));
				} catch (FileNotFoundException e1) {
					e1.printStackTrace();
				}
			}
			DataRow row = null;
			// first row
			row = read.next();
			if (row != null) {
				createPropertiesAndClasses(row);
			}

			try {
				for (row = read.next(); row != null; row = read.next()) {
					createIndividual(row);
//					if (monitor != null) {
//						monitor.worked(1);
//						monitor.subTask("Processing " + row.getString(0));
//					}
				}
			} catch (ArrayIndexOutOfBoundsException ae) {
				throw (ae);
			}

		} catch (Exception e) {
			throw (e);
		}

		finally {
			read.close();
		}
	}

	private void createOntologyClassHierarchy() throws Exception {
		DataFile read = createDataFile();

		try {
			try {
				read.open(new File(trans.getFileIn()));
			} catch (IOException e) {
				try {
					read.open(new File(ResourceLoader
							.getPath(trans.getFileIn())));
				} catch (FileNotFoundException e1) {
					e1.printStackTrace();
				}
			}
			DataRow row = null;
			// first row ignore
			// row = read.next();

			try {
				for (row = read.next(); row != null; row = read.next()) {
					createHierachyClass(row);
//					if (monitor != null) {
//						monitor.worked(1);
//						monitor.subTask("Processing " + row.getString(0));
//					}
				}
			} catch (ArrayIndexOutOfBoundsException ae) {
				throw (ae);
			}

		} catch (Exception e) {
			throw (e);
		}

		finally {
			read.close();
		}

	}

	private void createIndividual(DataRow row) {
		// create individual
		Individual ind = null;
		try {
			if (!trans.isTreatAsHierarchy()) {
				int id = trans.getColumnForPrimaryClass();

				if (!trans.isGenerateAutoIds()) {
					ind = createIndividual(row, id, classForTerms);
				} else {
					createAutoGeneratedIdIndividual(row, id, classForTerms);
				}

				// add the properties
				createNotHierarchyIndividual(ind, row);

			} else {
				createHierarchyIndividuals(row);

			}
		} catch (ArrayIndexOutOfBoundsException e) {
			e.printStackTrace();
		}

	}

	private void createHierachyClass(DataRow row) {
		OntClass clsTmp = null;
		OntClass cls = null;
		for (int i = 0; i < row.size(); i++) {
			cls = createClass(row, i);

			if (clsTmp != null) {
				cls.setSuperClass(clsTmp);
//				clsTmp.setSubClass(cls);
				logger.info( clsTmp.getLocalName() + "  <-   " + cls.getLocalName());
			}

			if (i + 1 < row.size()) {
				// there are more classes down the tree
//				newOntModel.add(cls, rdf)
//				Statement sta = newOntModel.getResource(clsTmp).getProperty(p)
				
				clsTmp = newOntModel.getOntClass(cls.getURI());
			} else {
				clsTmp = null;
			}

		}
	}

	private void createHierarchyIndividuals(DataRow row) {

		// create individuals
		for (int i = 0; i < row.size(); i++) {
			OntClass cls1 = (OntClass) res[i];
			createIndividual(row, i, cls1);

		}

		for (int i = 0; i < row.size() - 1; i++) {
			Individual ind1 = getIndividual(row, i);
			Individual ind2 = getIndividual(row, i + 1);
			// create defined relations up-down or left to right

			if (ind1 != null && ind2 != null) {

				ObjectProperty pud = propetiesForHierarchiesUp_Down[i];
				ind1.addProperty(pud, ind2);

				// create defined relations down-up or right to left
				if (trans.isCreateAllRelationsHierarchy()) {
					ObjectProperty pdu = propetiesForHierarchiesDown_Up[i];
					ind2.addProperty(pdu, ind1);
				}
			}
		}

	}

	private void createNotHierarchyIndividual(Individual ind, DataRow row) {

		if (ind != null) {
			for (int i = 0; i < row.size(); i++) {
				// this contains either classes or datatypeproperties
				Resource r = res[i];
				if (row.getString(i).length() > 0) {
					if (r instanceof OntClass) {
						OntClass cls = (OntClass) r;
						Individual ind2 = createIndividual(row, i, cls);
						ObjectProperty p = getPropertyForARangeClass(cls);
						if (cls == null || ind2 == null || p == null
								|| ind == null) {
							System.err.println("cls " + cls + "  p " + p
									+ "  ind2 " + ind2 + " ind " + ind);
						} else {
							ind.addProperty(p, ind2);
							if (trans.isCreateAllRelationsHierarchy()) {
								// create the inverse property
								ObjectProperty p2 = getPropertyForARangeClassWhenTreatedAsHiera(
										cls, classForTerms);
								ind2.addProperty(p2, ind);
								p2.setInverseOf(p);

							}
						}

					} else {
						DatatypeProperty dp = (DatatypeProperty) r;
						ind.addProperty(dp, row.getString(i).trim());

					}
				}

			}
		}

	}

	private String cleanStringforID(String s) {

		return stringManipulation.replaceString(s.trim());

	}

	public StringManipulationInterface getStringManipulation() {
		return stringManipulation;
	}

	public void setStringManipulation(
			StringManipulationInterface stringManipulation) {
		this.stringManipulation = stringManipulation;
	}

	public OntModel getOntology() {
		return newOntModel;

	}

}
